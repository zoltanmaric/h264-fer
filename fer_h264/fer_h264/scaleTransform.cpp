//#include <math.h>
#include "scaleTransform.h"
#include "headers_and_parameter_sets.h"
#include "h264_globals.h"

void ScalingFunctions4x4Derivation(int LevelScale[6][4][4]);//, int iYCbCr);
int normAdjust(int m, int i, int j);

//Multiplication factors for quantization
int factorsQ[6][4][4] = 
{
	{{13107,8066,13107,8066},{8066,5243,8066,5243},{13107,8066,13107,8066},{8066,5243,8066,5243}},
	{{11916,7490,11916,7490},{7490,4660,7490,4660},{11916,7490,11916,7490},{7490,4660,7490,4660}},
	{{10082,6554,10082,6554},{6554,4194,6554,4194},{10082,6554,10082,6554},{6554,4194,6554,4194}},
	{{9362,5825, 9352,5825},{5825,3647,5825,3647},{9362,5825, 9352,5825},{5825,3647,5825,3647}},
	{{8192,5243, 8192,5243},{5243,3355,5243,3355},{8192,5243, 8192,5243},{5243,3355,5243,3355}},
	{{7282,4559, 7282,4559},{4559,2893,4559,2893},{7282,4559, 7282,4559},{4559,2893,4559,2893}}
};

//Scaling factors if Ian Richardson's scaling expressions are used
int factorsDQ[6][4][4] = 
{
	{{10,13,10,13},{13,16,13,16},{10,13,10,13},{13,16,13,16}},
	{{11,14,11,14},{14,18,14,18},{11,14,11,14},{14,18,14,18}},
	{{13,16,13,16},{16,20,16,20},{13,16,13,16},{16,20,16,20}},
	{{14,18,14,18},{18,23,18,23},{14,18,14,18},{18,23,18,23}},
	{{16,20,16,20},{20,25,20,25},{16,20,16,20},{20,25,20,25}},
	{{18,23,18,23},{23,29,23,29},{18,23,18,23},{23,29,23,29}}	
};

// This lookup table is generated by the function ScalingFunctions4x4Derivation
int LevelScale[6][4][4] =
{
	{{160,208,160,208},{208,256,208,256},{160,208,160,208},{208,256,208,256}},
	{{176,224,176,224},{224,288,224,288},{176,224,176,224},{224,288,224,288}},
	{{208,256,208,256},{256,320,256,320},{208,256,208,256},{256,320,256,320}},
	{{224,288,224,288},{288,368,288,368},{224,288,224,288},{288,368,288,368}},
	{{256,320,256,320},{320,400,320,400},{256,320,256,320},{320,400,320,400}},
	{{288,368,288,368},{368,464,368,464},{288,368,288,368},{368,464,368,464}}
};

int ZigZagReordering[16][2] = 
{
	{0,0}, {0,1}, {1,0}, {2,0}, {1,1}, {0,2}, {0,3}, {1,2},
	{2,1}, {3,0}, {3,1}, {2,2}, {1,3}, {2,3}, {3,2}, {3,3}
};

int v[6][3] = {{10, 16, 13}, {11, 18, 14},
			   {13, 20, 16}, {14, 23, 18},
			   {16, 25, 20}, {18, 29, 23}};

// Help functions that are not used, lookup table is used instead
//---------------------------------------------------//
//---------------------------------------------------//

int normAdjust(int m, int i, int j)
{
	if ((i%2 == 0) && (j%2 == 0))
	{
		return v[m][0];
	}
	else if ((i%2 == 1) && (j%2 == 1))
	{
		return v[m][1];
	}
	else
	{
		return v[m][2];
	}
}

void ScalingFunctions4x4Derivation(int LevelScale[6][4][4])
{
	bool mbIsInterFlag = false;
	if ((shd.slice_type % 5 == P_SLICE) ||
		(shd.slice_type % 5 == B_SLICE) ||
		(shd.slice_type % 5 == SP_SLICE))
	{
		mbIsInterFlag = true;
	}

	// Standard: separate_colour_plane_flag == 0 in baseline
	
	for (int m = 0; m < 6; m++)
	{
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				// weightScale4x4 == 16 for any i,j (expression 7-7)
				LevelScale[m][i][j] = 16 * normAdjust(m, i, j);
			}
		}
	}
}


// --------------------------------------------------//
// 8.5.12.2 Transformation process for residual 4x4 blocks
void inverseTransform4x4(int d[4][4], int r[4][4])
{	
	int e[4][4], f[4][4], g[4][4], h[4][4];
	
	for (int i = 0; i < 4; i++)
	{
		e[i][0] = d[i][0] + d[i][2];
		e[i][1] = d[i][0] - d[i][2];
		e[i][2] = (d[i][1] >> 1) - d[i][3];
		e[i][3] = d[i][1] + (d[i][3] >> 1);
	}

	for (int i = 0; i < 4; i++)
	{
		f[i][0] = e[i][0] + e[i][3];
		f[i][1] = e[i][1] + e[i][2];
		f[i][2] = e[i][1] - e[i][2];
		f[i][3] = e[i][0] - e[i][3];
	}

	for (int j = 0; j < 4; j++)
	{
		g[0][j] = f[0][j] + f[2][j];
		g[1][j] = f[0][j] - f[2][j];
		g[2][j] = (f[1][j] >> 1) - f[3][j];
		g[3][j] = f[1][j] + (f[3][j] >> 1);
	}

	for (int j = 0; j < 4; j++)
	{
		h[0][j] = g[0][j] + g[3][j];
		h[1][j] = g[1][j] + g[2][j];
		h[2][j] = g[1][j] - g[2][j];
		h[3][j] = g[0][j] - g[3][j];
	}

	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			r[i][j] = (h[i][j] + 32) >> 6;
		}
	}
}

// --------------------------------------------------//
// 8.5.10 (part 1) Transformation process for DC transform coefficients for Intra_16x16 macroblock type  
void inverseTransformDCLumaIntraFast (int c[4][4], int f[4][4])
{
	int d[4][4], e[4][4], g[4][4];
	
	for (int i = 0; i < 4; i++)
	{
		d[i][0] = c[i][0] + c[i][2];
		d[i][1] = c[i][0] - c[i][2];
		d[i][2] = c[i][1] - c[i][3];
		d[i][3] = c[i][1] + c[i][3];
	}

	for (int i = 0; i < 4; i++)
	{
		e[i][0] = d[i][0] + d[i][3];
		e[i][1] = d[i][1] + d[i][2];
		e[i][2] = d[i][1] - d[i][2];
		e[i][3] = d[i][0] - d[i][3];
	}

	for (int j = 0; j < 4; j++)
	{
		g[0][j] = e[0][j] + e[2][j];
		g[1][j] = e[0][j] - e[2][j];
		g[2][j] = e[1][j] - e[3][j];
		g[3][j] = e[1][j] + e[3][j];
	}

	for (int j = 0; j < 4; j++)
	{
		f[0][j] = g[0][j] + g[3][j];
		f[1][j] = g[1][j] + g[2][j];
		f[2][j] = g[1][j] - g[2][j];
		f[3][j] = g[0][j] - g[3][j];
	}
}

// --------------------------------------------------//
// 8.5.10 (part 1) Transformation process for DC transform coefficients for Intra_16x16 macroblock type  
void inverseTransformDCLumaIntra (int c[4][4], int f[4][4])
{
	int i, j;
	int f_temp[4][4];

	//multiply A*c
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			switch (i)
			{
				case 0: 
					f_temp[i][j] = c[0][j] + c[1][j] + c[2][j] + c[3][j];					
					break;
				case 1: 					
					f_temp[i][j] = c[0][j] + c[1][j] - c[2][j] - c[3][j];
					break;
				case 2:
					f_temp[i][j] = c[0][j] - c[1][j] - c[2][j] + c[3][j];
					break;
				case 3:					
					f_temp[i][j] = c[0][j] - c[1][j] + c[2][j] - c[3][j];
					break;
			}
		}
	}
	
	//multiply (A*c)*At
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			switch (j)
			{
				case 0: 
					f[i][j] = f_temp[i][0] + f_temp[i][1] + f_temp[i][2] + f_temp[i][3];
					break;
				case 1: 					
					f[i][j] = f_temp[i][0] + f_temp[i][1] - f_temp[i][2] - f_temp[i][3];
					break;
				case 2:
					f[i][j] = f_temp[i][0] - f_temp[i][1] - f_temp[i][2] + f_temp[i][3];
					break;
				case 3:					
					f[i][j] = f_temp[i][0] - f_temp[i][1] + f_temp[i][2] - f_temp[i][3];
					break;
			}
		}
	}
}

// --------------------------------------------------//
// 8.5.11.1 Transformation process for chroma DC transform coefficients
void transformDCChromaFast (int c[2][2], int f[2][2])
{
	int d[2][2];

	d[0][0] = c[0][0] + c[1][0];
	d[0][1] = c[0][1] + c[1][1];
	d[1][0] = c[0][0] - c[1][0];
	d[1][1] = c[0][1] - c[1][1];

	f[0][0] = d[0][0] + d[0][1];
	f[0][1] = d[0][0] - d[0][1];
	f[1][0] = d[1][0] + d[1][1];
	f[1][1] = d[1][0] - d[1][1];
	
}

// --------------------------------------------------//
// 8.5.11.1 Transformation process for chroma DC transform coefficients
void transformDCChroma (int c[2][2], int f[2][2])
{
	int i, j;
	int f_temp[2][2];

	//multiply A*W
	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 2; j++)
		{
			switch (i)
			{
				case 0: 
					f_temp[i][j] = c[0][j] + c[1][j];
					break;
				case 1: 					
					f_temp[i][j] = c[0][j] - c[1][j];
					break;				
			}
		}
	}
	
	//multiply (A*W)*At
	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 2; j++)
		{
			switch (j)
			{
				case 0: 
					f[i][j] = f_temp[i][0] + f_temp[i][1];
					break;
				case 1: 					
					f[i][j] = f_temp[i][0] - f_temp[i][1];
					break;				
			}
		}
	}
}


// --------------------------------------------------//
// 8.5.12.1 Scaling process for residual 4x4 blocks
void scaleResidualBlock(int c[4][4], int d[4][4], int qP, bool intra16x16OrChroma)
{	
	int qPCalculated = qP / 6;	
	int qbits;
	int qPMod = qP % 6;

	if (qP >= 24)
	{
		qbits = qPCalculated - 4;		
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				d[i][j] = (c[i][j] * LevelScale[qPMod][i][j]) << qbits;
			}
		}
	}
	else
	{
		int adjust = 1 << (3 - qPCalculated);
		qbits = 4 - qPCalculated;

		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				d[i][j] = (c[i][j] * LevelScale[qPMod][i][j] + adjust) >> qbits;
			}
		}
	}	

	if (intra16x16OrChroma) d[0][0] = c[0][0];	
}

// --------------------------------------------------//
//8.5.10 (part 2) Scaling process for DC transform coefficients for Intra_16x16 macroblock type
void scaleLumaDCIntra(int f[4][4], int qP, int dcY[4][4])
{
	int qP_calculate = qP/6;
	//int scaleV = factorsDQ[qP%6][0][0];
	int scaleL = LevelScale[qP%6][0][0];
	int qbits;

	//Scaling proccess according to the latest H.264 ITU specification
	
	if (qP >= 36)
	{
		qbits = qP_calculate - 6;
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				dcY[i][j] = (f[i][j] * scaleL) << qbits;
			}
		}
	}
	else
	{
		int adjust = 1 << (5 - qP_calculate);
		qbits = 6 - qP_calculate;

		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				dcY[i][j] = (f[i][j] * scaleL + adjust) >> qbits;
			}
		}
	}

	//Scaling process according to the Ian Richardson's book
	/*
	int shift12 = qp_calculate-2;
	int shift0 = 2 - qp_calculate;

	if (qp >= 12)
	{
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				dcY[i][j] = (f[i][j]*scaleV) << shift12;
			}
		}
	}
	else
	{
		int pom = 1 << (1 - qp);
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				dcY[i][j] = (f[i][j]*scaleV + pom) >> shift0;
			}
		}
	}*/	
}

// --------------------------------------------------//
//8.5.11.2 Scaling process for chroma DC transform coefficients
void scaleChromaDC(int f[2][2], int qP, int dcC[2][2])
{
	int qP_calculate = qP/6;
	//int scaleV = factorsDQ[qp%6][0][0];
	int scaleL = LevelScale[qP%6][0][0];

	//Scaling process according to the latest H.264 ITU specification	
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			dcC[i][j] = ((f[i][j] * scaleL) << qP_calculate) >> 5;
		}
	}

	// Scaling process according to the Ian Richardson's book
	/*
	if (qP >= 6)
	{
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				dcC[i][j] = (f[i][j]*scaleV) << (qp_calculate - 1);
			}
		}		
	}
	else
	{
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				dcC[i][j] = (f[i][j]*scaleV) >> 1;
			}
		}
	}*/		
}


//---------------------------------------------------//
//---------------- PUBLIC FUNCTIONS -----------------//
//---------------------------------------------------//

//---------------------------------------------------//
// 8.5.6 Inverse scanning process for 4x4 transform coefficients and scaling lists 
void transformInverseScan(int list[16], int c[4][4])
{
	for (int i = 0; i < 16; i++)
	{
		int x = ZigZagReordering[i][0];
		int y = ZigZagReordering[i][1];
		c[x][y] = list[i];
	}
}
// --------------------------------------------------//
// 8.5.12 Scaling and transformation process for residual 4x4 blocks
void inverseResidual(int bitDepth, int qP, int c[4][4], int r[4][4], bool intra16x16OrChroma)
{
	int d[4][4];

	scaleResidualBlock(c, d, qP, intra16x16OrChroma);
	inverseTransform4x4(d, r);
}
// --------------------------------------------------//
// 8.5.10 Scaling and transformation process for DC transform coefficients for Intra_16x16 macroblock type
void InverseDCLumaIntra (int bitDepth, int qP, int c[4][4], int dcY[4][4])
{
	int f[4][4];

	inverseTransformDCLumaIntraFast(c, f);
	scaleLumaDCIntra(f, qP, dcY);	
}
// --------------------------------------------------//
// 8.5.11 Scaling and transformation process for chroma DC transform coefficients 
void InverseDCChroma (int bitDepth, int qP, int c[2][2], int dcC[2][2])
{
	int f[2][2];

	transformDCChromaFast(c, f);
	scaleChromaDC(f, qP, dcC);	
}



